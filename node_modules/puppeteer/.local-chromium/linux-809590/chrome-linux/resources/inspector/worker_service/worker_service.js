class s{dispose(){}setNotify(s){}}const e=self,t=new class{constructor(s){this._port=s,this._port.onmessage=this._onMessage.bind(this),this._port.onerror=console.error}setHandlers(s,e){this._messageHandler=s,this._closeHandler=e}send(s){return this._port.postMessage(s),Promise.resolve()}close(){return Promise.resolve()}_onMessage(s){this._messageHandler(s.data)}}(e);[].push(new class{constructor(s){this._objects=new Map,this._lastObjectId=1,this._port=s,this._port.setHandlers(this._dispatchMessageWrapped.bind(this),this._connectionClosed.bind(this))}_dispatchMessageWrapped(s){let e;try{if(e=JSON.parse(s),!(e instanceof Object))return void this._sendErrorResponse(e.id,"Malformed message");this._dispatchMessage(e)}catch(s){this._sendErrorResponse(e?e.id:"",s.toString()+" "+s.stack)}}_dispatchMessage(e){const t=e.method.split("."),o=t[0],i=t[1];if("create"===i){const t=self.runtime.extensions(s).filter(s=>s.descriptor().name===o);if(!t.length)return void this._sendErrorResponse(e.id,"Could not resolve service '"+o+"'");t[0].instance().then(s=>{const t=String(this._lastObjectId++);s.setNotify(this._notify.bind(this,t,o)),this._objects.set(t,s),this._sendResponse(e.id,{id:t})})}else if("dispose"===i){const s=this._objects.get(e.params.id);if(!s)return void console.error("Could not look up object with id for "+JSON.stringify(e));this._objects.delete(e.params.id),s.dispose().then(()=>this._sendResponse(e.id,{}))}else{if(!e.params)return void console.error("No params in the message: "+JSON.stringify(e));const s=this._objects.get(e.params.id);if(!s)return void console.error("Could not look up object with id for "+JSON.stringify(e));if(!(s[i]instanceof Function))return void console.error("Handler for '"+i+"' is missing.");s[i](e.params).then(s=>this._sendResponse(e.id,s))}}_connectionClosed(){for(const s of this._objects.values())s.dispose();this._objects.clear()}_notify(s,e,t,o){o.id=s;const i={method:e+"."+t,params:o};this._port.send(JSON.stringify(i))}_sendResponse(s,e){const t={id:s,result:e};this._port.send(JSON.stringify(t))}_sendErrorResponse(s,e){const t={id:s,error:e};this._port.send(JSON.stringify(t))}}(t)),self.Service=s;
